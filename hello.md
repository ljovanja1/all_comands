HELLO IT'S ROMAN
# Краткое руговодство по Git
# Основные команды
## Как задать имя пользователя и адрес электронной почты
* git config --global user.name "\" - задать имя пользователя
* git config --global user.email "\" -задать адрес электронной почты
## Кэширование учётных данных
* git config --global credential.helper cache - Кэшировать учётные данные можно с помощью параметра config с флагом --global. Так вы избавитесь от необходимости вручную вводить имя пользователя и пароль при создании нового коммита.
## Инициализация репозитория
* git init — создать репозиторий в папке на локальной машине,
## Добавление отдельных файлов или всех файлов в область подготовленных файлов
* git add somefile.js - Добавить отдельный файл в область подготовленных файлов можно параметром add с указанием имени файла. Просто замените somefile.js на актуальное имя
* git add . - Кроме того, можно добавить все файлы и папки в эту область, предоставив wildcard . вместо имени файла:
## Проверка статуса репозитория
* git status - Проверка статуса репозитория
## Внесение изменений однострочным сообщением или через редактор
* git commit + комментарий — сохранить текущее состояние,
## Просмотр истории коммитов с изменениями
* git log — вызывать список действий и сохранений,
## Просмотр заданного коммита
* git show 1af17e - Просмотр заданного коммита
## Просмотр изменений до коммита
* git diff — показать разницу между версиями,
* git diff --staged - Для просмотра подготовленных изменений необходимо добавить флаг --staged
## Отмена подготовленных и неподготовленных изменений
* git chechout — переключиться между разными версиями.
* git reset HEAD - Если нужно выполнить это действие для всех подготовленных файлов, путь к ним указывать не надо.
* git reset HEAD somefile.js - Восстановить подготовленный файл рабочего дерева можно параметром reset
## Удаление отслеживаемых файлов из текущего рабочего дерева
* git rm dirname/somefile.js - Удаление отслеживаемых файлов из (текущего рабочего дерева somefile.js)
* git rm dirname/*.html - Можно также использовать маски файлов (например *.js) для удаления всех файлов, соответствующих критерию.
## Переименование файлов
* git mv dir1/somefile.js dir2 - Переименовать файл или папку можно параметром mv
## Изменение последнего коммита
* git commit --amend -m "Изменение последнего коммита" - Изменение последнего коммита
## Откат последнего коммита
* git revert HEAD - Откат последнего коммита
## Разница между revert и reset 
* Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.
## Откат заданного коммита
* git revert 1af17e
## Ветки
* git branch - выводит список веток
* git branch Branch_name - создает новую ветку с именем branch_name
* git merge - сливает ветки
## Удаление ветки
* git branch -d existing_branch_name
* git branch -D existing_branch_name - Для принудительного удаления ветки используется флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений
* git push origin --delete existing_branch_name - Если хотите стереть удалённую ветку
## Слияние двух веток
* git merge existing_branch_name 
* git merge --no-ff existing_branch_name - Указанная команда объединит заданную ветку с основной и произведёт коммит слияния. Это необходимо для фиксации всех слияний в вашем репозитории.
## Отображение журнала фиксации в виде графика для текущей или всех веток
Просмотреть историю коммитов в виде графика для текущей ветки можно с помощью параметра log и флагов --graph --oneline --decorate. Опция --graph выведет график в формате ASCII, отражающий структуру ветвления истории коммитов. В связке с флагами --oneline и --decorate, этот флаг упрощает понимание того, к какой ветке относится каждый коммит.
* git log --graph --oneline --decorate
* git log --graph - позволяет отобразить коммиты в виде дерева.
* git log --all --graph --oneline --decorate -Для просмотра истории коммитов по всем веткам используется флаг --all
## Прекращение слияния при конфликте
* git merge --abort - позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.
* git reset - Также при конфликте слияния можно использовать параметр reset, чтобы восстановить конфликтующие файлы до стабильного состояния.
## Добавление удалённого репозитория
* git remote add awesomeapp https://github.com/someurl.. - Добавить удалённый репозиторий можно параметром remote add, указав shortname и url требуемого репозитория.
## Просмотр удалённых URL-адресов
* git remote -v - Просматривать удалённые URL-адреса можно параметром remote с флагом -v. Этот параметр отображает удалённые подключения к другим репозиториям.
## Получение дополнительных сведений об удалённом репозитории
* git remote show origin - Получить подробные сведения об удалённом репозитории можно с помощью параметра remote show с указанием имени репозитория — например, origin
## Отправка изменений в удалённый репозиторий
* git push origin main - Отправлять изменения в удалённый репозиторий можно параметром push с указанием имени репозитория и ветки.
## Получение изменений из удалённого репозитория
* git pull - скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией
* git pull --verbose - Также можно просмотреть подробные сведения о загруженных файлах с помощью флага --verbose.
## Слияние удалённого репозитория с локальным
* git merge - Слияние удалённого репозитория с локальным выполняется параметром merge с указанием имени удалённого репозитория.
##  Отправка новой ветки в удалённый репозиторий
* git push -u origin new_branch - Передать новую ветку в удалённый репозиторий можно параметром push с флагом -u, указав имя репозитория и имя ветки.
## Удаление удалённой ветки
* git push --delete origin existing_branch - Чтобы избавиться от удалённой ветки, используйте параметр push с флагом --delete, указав имя удалённого репозитория и имя ветки.
## Использование перебазирования
* it rebase branch_name - Перебазирование — это процесс объединения или перемещения последовательности коммитов на новый родительский снимок
# cherry-pick
kопировать несколько коммитов на место, где сейчас находишься (HEAD)
* git cherry-pick <Commit1> <Commit2> <...>